#include <stdio.h>

/* FreeRTOS and ESP-IDF headers */
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_log.h"
#include "esp_system.h"
#include "esp_rom_sys.h"
#include "esp_timer.h"
#include "driver/gpio.h"
#include "driver/ledc.h"
#include "esp_mac.h"
#include <driver/uart.h>
#include "driver/gptimer.h"
#include "freertos/semphr.h"

/* micro-ROS headers */
#include <uros_network_interfaces.h>
#include <rcl/rcl.h>
#include <rcl/error_handling.h>
#include <rclc/rclc.h>
#include <rclc/executor.h>

#include "geometry_msgs/msg/pose.h"
#include <rosidl_runtime_c/string_functions.h>
#include <rosidl_runtime_c/primitives_sequence_functions.h>

#include "inverse_kinematics.h"

#define TIMER_INTERVAL_US (2000)

const int DOF = 6;
const float a1 = 100.0f;
const float a2 = 500.0f;
const float a3 = 500.0f;
const float a4 = 100.0f;
const float a5 = 100.0f;
const float a6 = 100.0f;

float d4 = a3 + a4;
float d6 = a4 + a5;

//-------JOINT LIMITS-------//

const float q_min[6] = {
    -165.0f * ((float)M_PI / 180.0f),
    -70.0f  * ((float)M_PI / 180.0f),
    -160.0f * ((float)M_PI / 180.0f),
    -160.0f * ((float)M_PI / 180.0f),
    -120.0f * ((float)M_PI / 180.0f),
    -360.0f * ((float)M_PI / 180.0f)
};

const float q_max[6] = {
     165.0f * ((float)M_PI / 180.0f),
     170.0f * ((float)M_PI / 180.0f),
     160.0f * ((float)M_PI / 180.0f),
     160.0f * ((float)M_PI / 180.0f),
     120.0f * ((float)M_PI / 180.0f),
     360.0f * ((float)M_PI / 180.0f)
};

static const char *TAG = "micro_ros";

#ifdef CONFIG_MICRO_ROS_ESP_XRCE_DDS_MIDDLEWARE
    #include <rmw_microros/rmw_microros.h>
#endif
#if defined(RMW_UXRCE_TRANSPORT_CUSTOM)
    #include <rmw_microxrcedds_c/config.h>
    #include "esp32_serial_transport.h"
    static uart_port_t uart_port = UART_NUM_1;
#endif

/* Error-checking macros for micro-ROS calls */
#define RCCHECK(fn) { rcl_ret_t temp_rc = fn; \
    if((temp_rc != RCL_RET_OK)) { \
        printf("Failed status on line %d: %d. Aborting.\n", __LINE__, (int)temp_rc); \
        esp_restart();\
        vTaskDelete(NULL); \
    } \
}
#define RCSOFTCHECK(fn) { rcl_ret_t temp_rc = fn; \
    if((temp_rc != RCL_RET_OK)) { \
        printf("Failed status on line %d: %d. Continuing.\n", __LINE__, (int)temp_rc); \
    } \
}

/* Subscription and message */
rcl_subscription_t pose_subscription;
geometry_msgs__msg__Pose pose_msg;


//---- TASK HANDLER----//
TaskHandle_t Controller_task = NULL;
TaskHandle_t Micro_Ros_task = NULL;
TaskHandle_t Can_Bus_task = NULL;

//---- SEMAPHORES & MUTEX ----//
static SemaphoreHandle_t executor_semaphore = NULL;
static SemaphoreHandle_t controller_semaphore = NULL;

static geometry_msgs__msg__Pose latest_pose;
static SemaphoreHandle_t pose_mutex = NULL;


static bool new_pose_available = false;
volatile uint32_t msg_count = 0;
int64_t last_time_us = 0;

bool ping_agent()
{
    return (rmw_uros_ping_agent(1000, 1) == RMW_RET_OK);
}

void reconnect_to_agent()
{
    ESP_LOGW(TAG, "Attempting to reconnect to micro-ROS Agent...");
    while (!ping_agent()) {
        vTaskDelay(pdMS_TO_TICKS(500));
    }
    ESP_LOGI(TAG, "Agent reachable. Resuming micro-ROS task.");
    esp_restart(); 
}

void pose_callback(const void * msgin) {
    const geometry_msgs__msg__Pose * msg = (const geometry_msgs__msg__Pose *)msgin;
    msg_count++;
    if (pose_mutex != NULL && xSemaphoreTake(pose_mutex, portMAX_DELAY) == pdTRUE) {
        memcpy(&latest_pose, msg, sizeof(geometry_msgs__msg__Pose));
        new_pose_available = true;
        xSemaphoreGive(pose_mutex);
    }
}

static bool IRAM_ATTR gptimer_callback(gptimer_handle_t timer, const gptimer_alarm_event_data_t *edata, void *user_data)
{    
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;

    if (executor_semaphore != NULL) {
        xSemaphoreGiveFromISR(executor_semaphore, &xHigherPriorityTaskWoken);
    }
    if (controller_semaphore != NULL) {
        xSemaphoreGiveFromISR(controller_semaphore, &xHigherPriorityTaskWoken);
    }

    if(xHigherPriorityTaskWoken) {
        portYIELD_FROM_ISR();
    }
    return true;
}

void hardware_timer_setup(uint64_t time_in_us)
{
    gptimer_handle_t gptimer = NULL;

    // Create the timer
    gptimer_config_t timer_config = {
        .clk_src = GPTIMER_CLK_SRC_DEFAULT, 
        .direction = GPTIMER_COUNT_UP,     
        .resolution_hz = 1000000,
    };
    ESP_ERROR_CHECK(gptimer_new_timer(&timer_config, &gptimer));

    gptimer_event_callbacks_t cbs = {
        .on_alarm = gptimer_callback,
    };
    ESP_ERROR_CHECK(gptimer_register_event_callbacks(gptimer, &cbs, NULL));

    gptimer_alarm_config_t alarm_config = {
        .reload_count = 0,
        .alarm_count = time_in_us, 
        .flags.auto_reload_on_alarm = true,
    };
    ESP_ERROR_CHECK(gptimer_set_alarm_action(gptimer, &alarm_config));
    ESP_ERROR_CHECK(gptimer_enable(gptimer));
    ESP_ERROR_CHECK(gptimer_start(gptimer));
}

void micro_ros_task(void * arg) 
{
    rcl_allocator_t allocator = rcl_get_default_allocator();
    rclc_support_t support;

    rcl_init_options_t init_options = rcl_get_zero_initialized_init_options();
    RCCHECK(rcl_init_options_init(&init_options, allocator));

    #if defined(CONFIG_MICRO_ROS_ESP_NETIF_WLAN) || defined(CONFIG_MICRO_ROS_ESP_NETIF_ENET)
        rmw_init_options_t* rmw_options = rcl_init_options_get_rmw_init_options(&init_options);

        // Static Agent IP and port can be used instead of autodisvery.
        RCCHECK(rmw_uros_options_set_udp_address(CONFIG_MICRO_ROS_AGENT_IP, CONFIG_MICRO_ROS_AGENT_PORT, rmw_options));
        //RCCHECK(rmw_uros_discover_agent(rmw_options));
    #endif

    // create init_options
    RCCHECK(rclc_support_init_with_options(&support, 0, NULL, &init_options, &allocator));
    geometry_msgs__msg__Pose__init(&pose_msg);

    /* Create a micro-ROS node */
    rcl_node_t node;
    RCCHECK(rclc_node_init_default(&node, "robot_controller", "", &support));
    
    RCCHECK(rclc_subscription_init_default(
        &pose_subscription,
        &node,
        ROSIDL_GET_MSG_TYPE_SUPPORT(geometry_msgs, msg, Pose),
        "target_pose"));  

    /* Executor */
    rclc_executor_t executor;
    RCCHECK(rclc_executor_init(&executor, &support.context, 1, &allocator));
    RCCHECK(rclc_executor_add_subscription(&executor, &pose_subscription, &pose_msg, &pose_callback, ON_NEW_DATA));

    while (1) {
        if (xSemaphoreTake(executor_semaphore, portMAX_DELAY) == pdTRUE) {
            rclc_executor_spin_some(&executor, RCL_MS_TO_NS(1));
        }

        static int64_t last_ping_time = 0;
        int64_t now_us = esp_timer_get_time();
        if (last_ping_time == 0) last_ping_time = now_us;

        if (now_us - last_ping_time >= 500000) { 
            if (!ping_agent()) {
                reconnect_to_agent();
            }
            last_ping_time = now_us;
        }
    }
}

void can_task(void *arg)
{
    while(1){

    vTaskDelay(pdMS_TO_TICKS(100));
    }
}


void controller_task(void *arg)
{
    geometry_msgs__msg__Pose pose_copy;
    geometry_msgs__msg__Pose__init(&pose_copy);
    float q_current[6];
    float q[6];
    while(1){
        if (xSemaphoreTake(controller_semaphore, portMAX_DELAY) == pdTRUE) {
            if (pose_mutex != NULL && xSemaphoreTake(pose_mutex, portMAX_DELAY) == pdTRUE) {
                pose_copy = latest_pose;
                xSemaphoreGive(pose_mutex);
            }
            float x = pose_copy.position.x;
            float y = pose_copy.position.y;
            float z = pose_copy.position.z;
            float qx = pose_copy.orientation.x;
            float qy = pose_copy.orientation.y;
            float qz = pose_copy.orientation.z;
            float qw = pose_copy.orientation.w;

            IK(x, y, z, qx, qy, qz, qw, q_current, q);
        }
    }
}

void app_main(void)
{
    #if defined(RMW_UXRCE_TRANSPORT_CUSTOM)
    rmw_uros_set_custom_transport(
        true,
        (void *) &uart_port,
        esp32_serial_open,
        esp32_serial_close,
        esp32_serial_write,
        esp32_serial_read
    );
    #elif defined(CONFIG_MICRO_ROS_ESP_NETIF_WLAN) || defined(CONFIG_MICRO_ROS_ESP_NETIF_ENET)
        ESP_ERROR_CHECK(uros_network_interface_initialize());
    #else
        #error micro-ROS transports misconfigured
    #endif  
    
    executor_semaphore = xSemaphoreCreateBinary();
    controller_semaphore = xSemaphoreCreateBinary();
    pose_mutex = xSemaphoreCreateMutex();

    if (executor_semaphore == NULL || controller_semaphore == NULL) {
        ESP_LOGE(TAG, "Failed to create semaphores\n");
        return;
    }
    if (pose_mutex == NULL) {
        ESP_LOGE(TAG, "Failed to create mutex\n");
        return;
    }

    xTaskCreatePinnedToCore(micro_ros_task, "uros_task", 16000, NULL, 10, &Micro_Ros_task, 0);
    xTaskCreatePinnedToCore(controller_task, "controller_task", 8192, NULL, 9, &Controller_task, 1);
    xTaskCreatePinnedToCore(can_task, "can_task", 4096, NULL, 8, &Can_Bus_task, 0);


    hardware_timer_setup(TIMER_INTERVAL_US);

    while (1)
    {
    int64_t now_us = esp_timer_get_time(); // microseconds since boot
    if (last_time_us == 0) last_time_us = now_us;

    int64_t elapsed_us = now_us - last_time_us;
    if (elapsed_us >= 1000000) { // every ~1 second
        float hz = (msg_count) / (elapsed_us / 1000000.0f);
        printf("Total subscription rate: %.2f Hz\n", hz);

        msg_count = 0;
        last_time_us = now_us;

        vTaskDelay(pdMS_TO_TICKS(100));
        }
    vTaskDelay(pdMS_TO_TICKS(10));
    }


    vTaskDelete(NULL);
}
