#include <stdio.h>
#include "matrix.h"

/* FreeRTOS and ESP-IDF headers */
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_log.h"
#include "esp_system.h"
#include "esp_rom_sys.h"
#include "esp_timer.h"
#include "driver/gpio.h"
#include "driver/ledc.h"
#include "esp_mac.h"
#include <driver/uart.h>
#include "driver/gptimer.h"
#include "freertos/semphr.h"
#include <esp_dsp.h>
#include "esp_twai.h"

/* micro-ROS headers */
#include <uros_network_interfaces.h>
#include <rcl/rcl.h>
#include <rcl/error_handling.h>
#include <rclc/rclc.h>
#include <rclc/executor.h>

#include "std_msgs/msg/float32_multi_array.h"
#include "sensor_msgs/msg/joint_state.h"
#include <rosidl_runtime_c/string_functions.h>
#include <rosidl_runtime_c/primitives_sequence_functions.h>

#include "inverse_kinematics.h"

#define TIMER_INTERVAL_US (2000)



static const char *TAG = "micro_ros";

#ifdef CONFIG_MICRO_ROS_ESP_XRCE_DDS_MIDDLEWARE
    #include <rmw_microros/rmw_microros.h>
#endif
#if defined(RMW_UXRCE_TRANSPORT_CUSTOM)
    #include <rmw_microxrcedds_c/config.h>
    #include "esp32_serial_transport.h"
    static uart_port_t uart_port = UART_NUM_1;
#endif

/* Error-checking macros for micro-ROS calls */
#define RCCHECK(fn) { rcl_ret_t temp_rc = fn; \
    if((temp_rc != RCL_RET_OK)) { \
        printf("Failed status on line %d: %d. Aborting.\n", __LINE__, (int)temp_rc); \
        esp_restart(); \
        vTaskDelete(NULL); \
    } \
}
#define RCSOFTCHECK(fn) { rcl_ret_t temp_rc = fn; \
    if((temp_rc != RCL_RET_OK)) { \
        printf("Failed status on line %d: %d. Continuing.\n", __LINE__, (int)temp_rc); \
        return; \
    } \
}

/* Subscription and message */
rcl_subscription_t robot_cmd_subscription;
std_msgs__msg__Float32MultiArray robot_cmd_msg;
rcl_publisher_t   joint_state_publisher;
sensor_msgs__msg__JointState joint_state_msg;


//---- TASK HANDLER----//
TaskHandle_t Controller_task = NULL;
TaskHandle_t Micro_Ros_task = NULL;
TaskHandle_t Can_Bus_task = NULL;

//---- SEMAPHORES & MUTEX ----//
static SemaphoreHandle_t executor_semaphore = NULL;
static SemaphoreHandle_t controller_semaphore = NULL;
static SemaphoreHandle_t q_mutex;


static float q_shared[6] = {0};


volatile uint32_t msg_count = 0;
int64_t last_time_us = 0;

bool ping_agent()
{
    return (rmw_uros_ping_agent(1000, 1) == RMW_RET_OK);
}

void reconnect_to_agent()
{
    ESP_LOGW(TAG, "Attempting to reconnect to micro-ROS Agent...");
    while (!ping_agent()) {
        vTaskDelay(pdMS_TO_TICKS(500));
    }
    ESP_LOGI(TAG, "Agent reachable. Resuming micro-ROS task.");
    esp_restart(); 
}


void robot_cmd_callback(const void * msgin) {
    const std_msgs__msg__Float32MultiArray * msg = (const std_msgs__msg__Float32MultiArray *)msgin;

    printf("robot_cmd: ");
    for (size_t i = 0; i < msg->data.size; i++) {
        printf("%.3f ", msg->data.data[i]);
    }
    printf("\n");
}

static bool IRAM_ATTR gptimer_callback(gptimer_handle_t timer, const gptimer_alarm_event_data_t *edata, void *user_data)
{    
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;

    if (executor_semaphore != NULL) {
        xSemaphoreGiveFromISR(executor_semaphore, &xHigherPriorityTaskWoken);
    }
    if (controller_semaphore != NULL) {
        xSemaphoreGiveFromISR(controller_semaphore, &xHigherPriorityTaskWoken);
    }

    if(xHigherPriorityTaskWoken) {
        portYIELD_FROM_ISR();
    }
    return true;
}

void hardware_timer_setup(uint64_t time_in_us)
{
    gptimer_handle_t gptimer = NULL;

    // Create the timer
    gptimer_config_t timer_config = {
        .clk_src = GPTIMER_CLK_SRC_DEFAULT, 
        .direction = GPTIMER_COUNT_UP,     
        .resolution_hz = 1000000,
    };
    ESP_ERROR_CHECK(gptimer_new_timer(&timer_config, &gptimer));

    gptimer_event_callbacks_t cbs = {
        .on_alarm = gptimer_callback,
    };
    ESP_ERROR_CHECK(gptimer_register_event_callbacks(gptimer, &cbs, NULL));

    gptimer_alarm_config_t alarm_config = {
        .reload_count = 0,
        .alarm_count = time_in_us, 
        .flags.auto_reload_on_alarm = true,
    };
    ESP_ERROR_CHECK(gptimer_set_alarm_action(gptimer, &alarm_config));
    ESP_ERROR_CHECK(gptimer_enable(gptimer));
    ESP_ERROR_CHECK(gptimer_start(gptimer));
}

void init_joint_state() {
    size_t joint_count = 6;

    // Initialize JointState struct
    sensor_msgs__msg__JointState__init(&joint_state_msg);

    // Initialize header.frame_id
    //rosidl_runtime_c__String__init(&joint_state_msg.header.frame_id);
    //rosidl_runtime_c__String__assign(&joint_state_msg.header.frame_id, "base_link");

    // Initialize header.stamp
    //joint_state_msg.header.stamp.sec = 0;
    //joint_state_msg.header.stamp.nanosec = 0;

    // Initialize name sequence
    rosidl_runtime_c__String__Sequence__init(&joint_state_msg.name, joint_count);
    for (size_t i = 0; i < joint_count; i++) {
        rosidl_runtime_c__String__init(&joint_state_msg.name.data[i]);
        char joint_name[16];
        snprintf(joint_name, sizeof(joint_name), "joint%zu", i + 1);
        rosidl_runtime_c__String__assign(&joint_state_msg.name.data[i], joint_name);
    }

    // Initialize position, velocity, effort sequences
    rosidl_runtime_c__double__Sequence__init(&joint_state_msg.position, joint_count);
    rosidl_runtime_c__double__Sequence__init(&joint_state_msg.velocity, 0);
    rosidl_runtime_c__double__Sequence__init(&joint_state_msg.effort, 0);

    // Set sizes explicitly
    joint_state_msg.position.size = joint_count;
    //joint_state_msg.velocity.size = joint_count;
    //joint_state_msg.effort.size   = joint_count;

}


void micro_ros_task(void * arg) 
{
    rcl_allocator_t allocator = rcl_get_default_allocator();
    rclc_support_t support;

    rcl_init_options_t init_options = rcl_get_zero_initialized_init_options();
    RCCHECK(rcl_init_options_init(&init_options, allocator));

    #if defined(CONFIG_MICRO_ROS_ESP_NETIF_WLAN) || defined(CONFIG_MICRO_ROS_ESP_NETIF_ENET)
        rmw_init_options_t* rmw_options = rcl_init_options_get_rmw_init_options(&init_options);

        // Static Agent IP and port can be used instead of autodisvery.
        RCCHECK(rmw_uros_options_set_udp_address(CONFIG_MICRO_ROS_AGENT_IP, CONFIG_MICRO_ROS_AGENT_PORT, rmw_options));
        //RCCHECK(rmw_uros_discover_agent(rmw_options));
    #endif

    // create init_options
    RCCHECK(rclc_support_init_with_options(&support, 0, NULL, &init_options, &allocator));

    /* Create a micro-ROS node */
    rcl_node_t node;
    RCCHECK(rclc_node_init_default(&node, "robot_controller", "", &support));
    std_msgs__msg__Float32MultiArray__init(&robot_cmd_msg);
    rosidl_runtime_c__float__Sequence__init(&robot_cmd_msg.data, 18);
    init_joint_state();  

    RCCHECK(rclc_publisher_init_best_effort(
        &joint_state_publisher,
        &node,
        ROSIDL_GET_MSG_TYPE_SUPPORT(sensor_msgs, msg, JointState),
        "joint_states"));
    
    RCCHECK(rclc_subscription_init_default(
        &robot_cmd_subscription,
        &node,
        ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, Float32MultiArray),
        "robot_cmd"));

    /* Executor */
    rclc_executor_t executor;
    RCCHECK(rclc_executor_init(&executor, &support.context, 3, &allocator));
    RCCHECK(rclc_executor_add_subscription(&executor, &robot_cmd_subscription, &robot_cmd_msg, &robot_cmd_callback, ON_NEW_DATA));

    while (1) {
        if (xSemaphoreTake(executor_semaphore, portMAX_DELAY) == pdTRUE) {
            rclc_executor_spin_some(&executor, RCL_MS_TO_NS(1));
        }

        static int64_t last_ping_time = 0;
        int64_t now_us = esp_timer_get_time();
        if (last_ping_time == 0) last_ping_time = now_us;

        if (now_us - last_ping_time >= 500000) { 
            if (!ping_agent()) {
                reconnect_to_agent();
            }
            last_ping_time = now_us;
        }

 

    }
}

void can_task(void *arg)
{
    while(1){

    vTaskDelay(pdMS_TO_TICKS(100));
    }
}


void controller_task(void *arg)
{
    float q_current[6];
    float q[6];
    

    while(1){
    vTaskDelay(pdMS_TO_TICKS(100));
    }
}

void app_main(void)
{
    #if defined(RMW_UXRCE_TRANSPORT_CUSTOM)
    rmw_uros_set_custom_transport(
        true,
        (void *) &uart_port,
        esp32_serial_open,
        esp32_serial_close,
        esp32_serial_write,
        esp32_serial_read
    );
    #elif defined(CONFIG_MICRO_ROS_ESP_NETIF_WLAN) || defined(CONFIG_MICRO_ROS_ESP_NETIF_ENET)
        ESP_ERROR_CHECK(uros_network_interface_initialize());
    #else
        #error micro-ROS transports misconfigured
    #endif  
    
    executor_semaphore = xSemaphoreCreateBinary();
    controller_semaphore = xSemaphoreCreateBinary();
    q_mutex = xSemaphoreCreateMutex();

    if (executor_semaphore == NULL || controller_semaphore == NULL) {
        ESP_LOGE(TAG, "Failed to create semaphores\n");
        return;
    }
    if ( q_mutex == NULL) {
        ESP_LOGE(TAG, "Failed to create mutex\n");
        return;
    }

    xTaskCreatePinnedToCore(micro_ros_task, "uros_task", 16000, NULL, 10, &Micro_Ros_task, 0);
    xTaskCreatePinnedToCore(controller_task, "controller_task", 8192, NULL, 9, &Controller_task, 1);
    xTaskCreatePinnedToCore(can_task, "can_task", 4096, NULL, 8, &Can_Bus_task, 0);


    hardware_timer_setup(TIMER_INTERVAL_US);

    while (1)
    {
    int64_t now_us = esp_timer_get_time(); 
    if (last_time_us == 0) last_time_us = now_us;

    int64_t elapsed_us = now_us - last_time_us;
    if (elapsed_us >= 1000000) { 
        float hz = (msg_count) / (elapsed_us / 1000000.0f);
        //printf("Total subscription rate: %.2f Hz\n", hz);

        msg_count = 0;
        last_time_us = now_us;

        vTaskDelay(pdMS_TO_TICKS(100));
        }
    vTaskDelay(pdMS_TO_TICKS(10));
    }


    vTaskDelete(NULL);
}
